# Hyperware Development Guide

## Overview

Hyperware is a personal server platform for building and running P2P applications. Applications are built using the hyperprocess framework, a Rust macro system that generates WebAssembly Interface (WIT) bindings and handles message passing, HTTP endpoints, and state management.

## Core Architecture

### Process Model
- Each application runs as an isolated WebAssembly process
- Processes communicate via message passing using the Request API
- Every process has a unique identifier: `process-name:package-name:publisher-node`
- State is automatically persisted based on SaveOptions configuration

### hyperprocess Framework
The `#[hyperprocess]` macro is the foundation of all Hyperware apps:
- Generates WIT bindings automatically
- Creates HTTP/WebSocket endpoint handlers
- Manages state persistence
- Provides lifecycle hooks (#[init])

### manifest.json Configuration

The `manifest.json` file is **CRITICAL** for your Hyperware app. Without it:
```
ERROR: failed to open file `pkg/manifest.json`
No such file or directory
```

#### Auto-Generation Process
manifest.json is automatically generated by `kit b --hyperapp`:
```
metadata.json → kit b --hyperapp → pkg/manifest.json
     ↓                                    ↓
Package name ←────── must match ─────→ process_name
```

#### Complete Structure
```json
[
  {
    "process_name": "my-app",              // Must match metadata.json package
    "process_wasm_path": "/my-app.wasm",   // Path to compiled WASM
    "on_exit": "Restart",                  // "Restart" or "None"
    "request_networking": true,            // Enable P2P messaging
    "request_capabilities": [              // System features needed
      "homepage:homepage:sys",
      "http-server:distro:sys"
    ],
    "grant_capabilities": [],              // Usually empty for apps
    "public": true                         // Can other processes message this?
  }
]
```

#### Field Reference
- **process_name**: Identifier matching metadata.json package name
- **process_wasm_path**: Location of compiled WebAssembly file  
- **on_exit**: 
  - `"Restart"`: Auto-restart on crash, preserves state
  - `"None"`: Stay dead, requires manual restart
- **request_networking**: Enables Request API for P2P messaging
- **request_capabilities**: Array of system permissions needed
- **grant_capabilities**: Permissions given to other processes (rare)
- **public**: 
  - `true`: Any process can message this one (default)
  - `false`: Only explicitly permitted processes can message
  - Note: HTTP/WebSocket endpoints still work regardless!

#### Process Identity Format
Every process has a unique identifier:
```
process-name:package-name:publisher-node
```
Examples:
- `skeleton-app:skeleton-app:skeleton.os`
- `samchat:samchat:hpn-testing-beta.os`

### Capabilities System
Hyperware uses a capability-based security model. Processes must request permissions in manifest.json:
- `homepage:homepage:sys` - Display app icon on homepage
- `http-server:distro:sys` - Serve UI and handle HTTP/WebSocket requests
- `vfs:distro:sys` - Virtual filesystem access
- `sqlite:distro:sys` - SQLite database (requires vfs)
- `http-client:distro:sys` - Make external HTTP requests
- `request_networking: true` - Enable P2P messaging via Request API

## Development Setup

### Project Structure
```
my-app/
├── Cargo.toml
├── metadata.json         # Package name and publisher
├── icon                  # App icon (optional)
├── manifest.json         # Auto-generated, defines capabilities
├── pkg/                  # Build output directory
├── src/
│   ├── lib.rs           # Main process implementation
│   └── icon             # Icon data file
└── ui/                  # Frontend React app
    ├── package.json
    ├── index.html
    └── src/
```

### Build Process
```bash
kit bs --hyperapp        # First-time build (installs dependencies)
kit b --hyperapp         # Regular build (Rust + UI, generates manifest.json)
kit s                    # Start local Hyperware node
```

The build process:
1. Reads metadata.json for package identity
2. Compiles Rust to WASM
3. Builds UI with Vite
4. Generates pkg/manifest.json from metadata + defaults
5. Creates deployable package in pkg/ directory

#### Build & Deploy Flow
1. **Write your code** with capabilities in mind
2. **Build**: `kit b --hyperapp` (generates manifest.json)
3. **Check**: Verify `pkg/manifest.json` was created
4. **Customize** manifest.json if needed (add capabilities, change settings)
5. **Install**: `kit s` to start and install
6. **Test** with multiple nodes for P2P features

#### Customizing Generated manifest.json
While auto-generated, you may need to modify it for:
- Additional capabilities (vfs, sqlite, eth, etc.)
- Different crash behavior (on_exit: "None" for dev)
- Security settings (public: false for sensitive apps)
- Grant capabilities to other processes

### Cargo.toml Configuration
**CRITICAL**: Do NOT add `hyperware_process_lib` to your Cargo.toml dependencies. It's provided by the hyperprocess macro. Adding it will cause "ambiguous" errors.

```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
# DO NOT add hyperware_process_lib here!

[dependencies.hyperprocess_macro]
git = "https://github.com/hyperware-ai/hyperprocess-macro"
```

## WIT Types and Data Modeling

### Type Constraints
WIT (WebAssembly Interface Types) has strict limitations:
- No generics (no Option<T>, Vec<T>, HashMap<K,V>)
- No recursive types
- No trait objects
- Limited enum support (no data in variants)
- Parameters must be concrete types

**Supported types**: bool, u8-u64, i8-i64, f32, f64, String, Vec<T>, Option<T>, tuples
**Not supported**: HashMap → use Vec<(K,V)>, arrays → use Vec<T>, &str → use String, complex enums → use simple enums + data struct

### Common Patterns
```rust
// WIT-compatible struct (needs PartialEq!)
#[derive(Serialize, Deserialize, PartialEq)]
struct Message {
    id: String,
    content: String,
    timestamp: String,    // Use RFC3339 strings for dates
    tags: Vec<String>,    // Concrete Vec types work
}

// Enum handling - simple variants only
#[derive(Serialize, Deserialize, PartialEq)]
enum Status {
    Active,
    Inactive,
    Pending,
}

// Complex data via struct + enum
#[derive(Serialize, Deserialize, PartialEq)]
struct Event {
    event_type: EventType,
    data: String,  // JSON-encoded event-specific data
}

// Backend state can use any Rust types
struct AppState {
    messages: HashMap<String, Message>,  // HashMap OK in state
    cache: Option<Data>,                 // Option OK in state
}

// HTTP handler with JSON serialization
#[http]
async fn get_messages(&self) -> Result<Vec<Message>, String> {
    // Convert internal HashMap to Vec for WIT
    Ok(self.messages.values().cloned().collect())
}
```

### TypeScript Compatibility
```rust
// Use serde rename for camelCase
#[derive(Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
struct UserProfile {
    user_id: String,      // → userId in JS
    display_name: String, // → displayName in JS
    is_active: bool,      // → isActive in JS
}

// Skip internal fields
#[derive(Serialize, Deserialize)]
struct State {
    public_data: Vec<Item>,
    #[serde(skip)]
    internal_cache: HashMap<String, Item>,
}
```

## HTTP Endpoints and API Patterns

### Endpoint Definition
```rust
#[hyperprocess(
    endpoints = vec![
        Binding::Http { 
            path: "/api", 
            config: HttpBindingConfig::new(false, false, false, None) 
        }
    ]
)]
```

### Request Handling

There are two approaches for HTTP parameter handling:

#### Modern Approach (with generated caller-utils)
```rust
#[http(method = "POST")]
async fn create_item(&mut self, request: CreateItemReq) -> Result<ItemInfo, String> {
    // Direct type deserialization
    // Requires generated TypeScript caller-utils
}
```

#### Legacy Approach (manual JSON parsing)
```rust
#[http]
async fn handle_request(&mut self, request_body: String) -> Result<String, String> {
    #[derive(Deserialize)]
    struct Request {
        action: String,
        data: serde_json::Value,
    }
    
    let req: Request = serde_json::from_str(&request_body)?;
    match req.action.as_str() {
        "create" => self.create_item(req.data),
        "update" => self.update_item(req.data),
        _ => Err("Unknown action".to_string()),
    }
}
```

**Note**: If you get "Failed to deserialize HTTP request" errors, use the legacy approach with `request_body: String` parameter.

### Frontend Integration
```typescript
const response = await fetch('/api', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ 
        CreateItem: { name: "Example" }  // Enum variant style
    })
});
```

## P2P Messaging Patterns

### Request API (Native P2P)
Requires `request_networking: true` in manifest.json:
```rust
use hyperware_process_lib::{Address, Request, ProcessId};

// Send and await response
let target = Address::new("node-name.os", "process:package:publisher".parse()?);
let response = Request::new()
    .target(target)
    .body(serde_json::to_vec(&message)?)
    .expects_response(30)
    .send_and_await_response(30)?;

// Fire-and-forget (still set expects_response!)
Request::new()
    .target(target)
    .body(data)
    .expects_response(30)  // Important for reliability
    .send();  // Don't await
```

### Endpoint Types
- **`#[http]`** - HTTP endpoints for frontend API calls
- **`#[remote]`** - Endpoints callable by other nodes via P2P
- **`#[local]`** - Internal endpoints within same node
- **`#[local] #[remote]`** - Callable both locally and remotely

### Remote Handler
```rust
#[remote]
async fn receive_message(&mut self, message: Message) -> Result<bool, String> {
    self.messages.push(message);
    Ok(true)
}
```

### Node Identity
```rust
// Get your node's identity
let my_node = our().node.clone();  // e.g., "alice.os"

// Store in state during init
#[init]
async fn initialize(&mut self) {
    self.my_node_id = Some(our().node.clone());
}
```

### ProcessId Parsing
```rust
// Format: "process:package:publisher"
let process_id = "samchat:samchat:publisher.os".parse::<ProcessId>()?;

// IMPORTANT: Publisher must be consistent across all nodes!
let publisher = "myapp.os";  // Same for ALL nodes
let process_id = format!("myapp:myapp:{}", publisher).parse::<ProcessId>()?;
```

### Making P2P Calls
```rust
// Build target address
let target_address = Address::new("bob.os", process_id);

// Wrap method name and data
let wrapper = json!({
    "RemoteMethodName": request_data  // Must match remote handler name exactly
});

// Send request
let response = Request::new()
    .target(target_address)
    .body(serde_json::to_vec(&wrapper)?)
    .expects_response(30)
    .send_and_await_response(30)?;

// Parse response
let result: MyResponse = serde_json::from_slice(&response.body())?;
```

## State Management and Persistence

### State Configuration
```rust
#[hyperprocess(
    save_config = SaveOptions::EveryMessage  // Auto-save after each message
)]
impl AppState {
    // State is automatically serialized/deserialized
}
```

### Storage Options

#### In-Memory + Auto-persist
```rust
#[derive(Default, Serialize, Deserialize)]
struct AppState {
    data: HashMap<String, Value>,  // Persisted automatically
}
```

#### SQLite Database

**⚠️ CRITICAL**: SQLite requires BOTH capabilities:
```json
"request_capabilities": [
  "sqlite:distro:sys",  // For database operations
  "vfs:distro:sys"      // Required! SQLite uses VFS internally
]
```

##### Basic Setup
```rust
use hyperware_process_lib::{sqlite, our};

#[derive(Default, Serialize, Deserialize)]
pub struct AppState {
    db: Option<sqlite::Sqlite>,
}

#[init]
async fn initialize(&mut self) {
    // Open database once at startup
    match sqlite::open(our().package_id(), "app_db", Some(5000)) {
        Ok(db) => {
            self.db = Some(db);
            
            // Create tables
            if let Some(ref db) = self.db {
                let sql = "CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    username TEXT NOT NULL UNIQUE,
                    email TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )".to_string();
                
                if let Err(e) = db.write(sql, vec![], None) {
                    println!("Failed to create table: {:?}", e);
                }
            }
        }
        Err(e) => println!("Failed to open database: {:?}", e),
    }
}
```

##### Core Operations
```rust
// Insert with parameters (prevents SQL injection)
let sql = "INSERT INTO users (username, email) VALUES (?, ?)".to_string();
let params = vec![
    json!("alice"),
    json!("alice@example.com")
];
db.write(sql, params, None)?;

// Query with parameters
let sql = "SELECT * FROM users WHERE email LIKE ?".to_string();
let params = vec![json!("%@example.com")];
let results = db.read(sql, params)?;
// results: Vec<HashMap<String, serde_json::Value>>

// Transactions
let tx_id = db.begin_tx()?;
db.write("INSERT INTO users (username) VALUES (?)".to_string(), 
         vec![json!("bob")], Some(tx_id))?;
db.write("INSERT INTO users (username) VALUES (?)".to_string(), 
         vec![json!("carol")], Some(tx_id))?;
db.commit_tx(tx_id)?; // or db.rollback_tx(tx_id)?
```

##### Parameter Types
```rust
// All parameters must be serde_json::Value
let params = vec![
    json!("string value"),           // String
    json!(123),                      // Integer
    json!(3.14),                     // Float
    json!(true),                     // Boolean (stored as 0/1)
    json!(null),                     // NULL
];

// Extracting values from results
for row in results {
    if let Some(serde_json::Value::String(name)) = row.get("name") {
        // Use name as &str
    }
    if let Some(serde_json::Value::Number(id)) = row.get("id") {
        if let Some(id_val) = id.as_i64() {
            // Use id_val as i64
        }
    }
}
```

##### Advanced Patterns
```rust
// Complex queries with JOINs
let sql = "SELECT 
    p.name as project_name,
    COUNT(t.id) as task_count
FROM projects p
LEFT JOIN tasks t ON p.id = t.project_id
GROUP BY p.id".to_string();

// Pagination
let sql = "SELECT * FROM users LIMIT ? OFFSET ?".to_string();
let params = vec![json!(20), json!(40)]; // 20 per page, page 3

// Create indexes for performance
db.write("CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)".to_string(), 
         vec![], None)?;
```

##### Error Handling
```rust
match db.write(insert_sql, params, None) {
    Ok(_) => Ok("Success".to_string()),
    Err(e) if e.to_string().contains("UNIQUE constraint") => {
        Err("Username already exists".to_string())
    }
    Err(e) => Err(format!("Database error: {:?}", e))
}
```

##### Common Errors
- **"doesn't have capability vfs:distro:sys"**: Add vfs capability
- **"no such table"**: Ensure CREATE TABLE runs before queries
- **"UNIQUE constraint failed"**: Handle duplicate key errors

#### Virtual Filesystem
```rust
use hyperware_process_lib::vfs::*;

create_directory("/app-data", None)?;
create_file("/app-data/config.json", None)?;
write_file("/app-data/config.json", json_bytes)?;
let data = read_file("/app-data/config.json")?;
```

### Database Patterns

#### Multi-Table Schema
```rust
// Create related tables with foreign keys
let schemas = vec![
    "CREATE TABLE IF NOT EXISTS projects (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        owner_id INTEGER NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (owner_id) REFERENCES users(id)
    )",
    "CREATE TABLE IF NOT EXISTS tasks (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        project_id INTEGER NOT NULL,
        title TEXT NOT NULL,
        status TEXT DEFAULT 'pending',
        FOREIGN KEY (project_id) REFERENCES projects(id)
    )",
];

for schema in schemas {
    db.write(schema.to_string(), vec![], None)?;
}
```

#### Batch Operations with Transactions
```rust
#[http]
async fn batch_insert(&mut self, users: Vec<String>) -> Result<String, String> {
    if let Some(ref db) = self.db {
        let tx_id = db.begin_tx()?;
        
        let mut inserted = 0;
        for username in users {
            let sql = "INSERT INTO users (username) VALUES (?)".to_string();
            if db.write(sql, vec![json!(username)], Some(tx_id)).is_ok() {
                inserted += 1;
            }
        }
        
        db.commit_tx(tx_id)?;
        Ok(format!("Inserted {} users", inserted))
    } else {
        Err("Database not connected".to_string())
    }
}
```

#### Pagination Pattern
```rust
#[http]
async fn get_paginated(&self, page: u32, per_page: u32) -> Result<String, String> {
    if let Some(ref db) = self.db {
        let offset = page * per_page;
        let sql = "SELECT * FROM items LIMIT ? OFFSET ?".to_string();
        let params = vec![json!(per_page), json!(offset)];
        
        let items = db.read(sql, params)?;
        
        // Get total count
        let count_sql = "SELECT COUNT(*) as total FROM items".to_string();
        let count_result = db.read(count_sql, vec![])?;
        let total = count_result[0].get("total")
            .and_then(|v| v.as_i64())
            .unwrap_or(0);
        
        Ok(json!({
            "items": items,
            "page": page,
            "per_page": per_page,
            "total": total
        }).to_string())
    } else {
        Err("Database not connected".to_string())
    }
}
```

#### Search with Full-Text
```rust
#[http]
async fn search(&self, query: String) -> Result<String, String> {
    if let Some(ref db) = self.db {
        let sql = "SELECT * FROM articles 
                  WHERE title LIKE ? OR content LIKE ?
                  ORDER BY created_at DESC".to_string();
        let pattern = format!("%{}%", query);
        let params = vec![json!(pattern.clone()), json!(pattern)];
        
        let results = db.read(sql, params)?;
        Ok(json!({"results": results}).to_string())
    } else {
        Err("Database not connected".to_string())
    }
}
```

#### Database Maintenance
```rust
async fn perform_maintenance(&mut self) -> Result<(), String> {
    if let Some(ref db) = self.db {
        // Analyze for query optimization
        db.write("ANALYZE".to_string(), vec![], None)?;
        
        // Clean up old records
        let sql = "DELETE FROM logs WHERE created_at < datetime('now', '-30 days')".to_string();
        db.write(sql, vec![], None)?;
        
        Ok(())
    } else {
        Err("Database not connected".to_string())
    }
}
```

#### Best Practices
- Always check if database is connected before operations
- Use parameterized queries to prevent SQL injection
- Create indexes on frequently queried columns
- Use transactions for batch operations
- Set appropriate timeouts (5000ms recommended)
- Separate HTTP handlers from database logic

## Capabilities Reference

### Essential Capabilities
- **homepage:homepage:sys**: Required for `add_to_homepage()` - display app icon
- **http-server:distro:sys**: Serve UI, HTTP/WebSocket endpoints (includes WebSocket support!)
- **vfs:distro:sys**: Virtual filesystem access - store files, configs, uploads
- **sqlite:distro:sys**: Database access (⚠️ REQUIRES vfs:distro:sys too!)

### P2P Communication - IMPORTANT DISTINCTION

#### Native Request API (Recommended for P2P)
```rust
// Uses request_networking: true in manifest.json
Request::new()
    .target(Address::new(node_id, "process:package:publisher"))
    .body(message_bytes)
    .send_and_await_response(30)?;
```
- **Requires**: `"request_networking": true` in manifest.json
- **Does NOT require**: Any specific capability
- **Use for**: Direct process-to-process messaging between Hyperware nodes
- **More efficient** for P2P apps

#### HTTP Client to External APIs
```rust
// Uses http-client:distro:sys capability
use hyperware_process_lib::http::{ClientRequest, Method};

ClientRequest::new()
    .method(Method::Get)
    .url("https://api.example.com/data")
    .send()
    .await?;
```
- **Requires**: `"http-client:distro:sys"` capability
- **Use for**: External APIs, webhooks, OAuth, RSS feeds
- **NOT for P2P**: Use Request API instead

### Additional System Capabilities

- **eth:distro:sys**: Ethereum blockchain interaction (read data, send transactions, smart contracts)
- **timer:distro:sys**: Schedule delayed or recurring tasks
- **kv:distro:sys**: Simple key-value store for settings/preferences
- **net:tcp:sys** / **net:udp:sys**: Raw TCP/UDP networking for custom protocols

### What Doesn't Need Capabilities

Many browser APIs work without Hyperware capabilities:
- **WebRTC**: Audio/video calls, screen sharing
- **getUserMedia**: Camera/microphone access
- **Web Audio API**: Audio processing
- **Canvas/WebGL**: Graphics rendering
- **Geolocation**: Location services
- **IndexedDB**: Browser storage
- **Service Workers**: Offline functionality
- **Notifications API**: Browser notifications

These are browser-level APIs that only need user permission in the browser!

### Security Settings
- **public: true/false**: Whether other processes can message this one
- **grant_capabilities**: Give permissions to specific processes

### Capability Usage Examples

#### VFS Operations
```rust
use hyperware_process_lib::vfs::*;

// Create directory
create_directory("/app-data", None)?;

// Write file  
create_file("/app-data/config.json", None)?;
write_file("/app-data/config.json", config_bytes)?;

// Read file
let data = read_file("/app-data/config.json")?;

// List files
let entries = read_directory("/app-data")?;
```

#### Timer Operations
```rust
use hyperware_process_lib::timer::*;

// One-time timer (5 seconds)
set_timer(5000);

// Handle in message loop
match message {
    Message::Timer(_) => {
        // Timer fired!
        self.sync_data().await?;
    }
}
```

#### Key-Value Store
```rust
use hyperware_process_lib::kv::*;

// Set value
set("user:123", json!({"name": "Alice"}))?;

// Get value
let user = get("user:123")?;

// Delete
delete("user:123")?;

// List keys
let keys = list_keys("user:*")?;
```

### Common Capability Errors

#### "CapabilityNotFound"
```
Error: Process skeleton-app:skeleton-app:user.os does not have capability vfs:distro:sys
```
**Fix**: Add missing capability to manifest.json request_capabilities

#### "Messaging permission denied"
```
Error: Process X cannot message process Y
```
**Fix**: Either make target process `"public": true` or grant messaging capability

#### Feature silently fails
**Symptom**: Code runs but nothing happens  
**Cause**: Missing capability (no error thrown)
**Fix**: Check all system calls have matching capabilities

### Capability Requirements by Feature

| Feature | Required Capabilities |
|---------|----------------------|
| Show app icon | `homepage:homepage:sys` |
| Serve UI | `http-server:distro:sys` |
| API endpoints | `http-server:distro:sys` |
| WebSocket endpoints | `http-server:distro:sys` |
| External APIs | `http-client:distro:sys` |
| P2P messaging | `request_networking: true` (not a capability!) |
| File storage | `vfs:distro:sys` |
| Database | `sqlite:distro:sys` + `vfs:distro:sys` |
| Blockchain | `eth:distro:sys` |
| Scheduling | `timer:distro:sys` |
| Settings storage | `kv:distro:sys` |
| Custom networking | `net:tcp:sys`, `net:udp:sys` |
| WebRTC/Audio/Video | None (browser APIs) |

### manifest.json Examples

#### P2P Chat Application
```json
[
  {
    "process_name": "p2p-chat",
    "process_wasm_path": "/p2p-chat.wasm",
    "on_exit": "Restart",
    "request_networking": true,
    "request_capabilities": [
      "homepage:homepage:sys",
      "http-server:distro:sys",     // Serve UI and receive messages
      "vfs:distro:sys"              // Store chat history and files
    ],
    "grant_capabilities": [],
    "public": true                  // Allow messages from any node
  }
]
```

#### Real-time Voice/WebSocket App
```json
[
  {
    "process_name": "voice-chat",
    "process_wasm_path": "/voice-chat.wasm",
    "on_exit": "Restart",
    "request_networking": true,
    "request_capabilities": [
      "homepage:homepage:sys",
      "http-server:distro:sys",  // Includes WebSocket support!
      "vfs:distro:sys"           // For storing settings/history
    ],
    "grant_capabilities": [],
    "public": false              // More secure for voice apps
  }
]
```
Note: WebSocket support comes with `http-server:distro:sys` - no separate capability needed!

#### System Monitor with Terminal Access
```json
[
  {
    "process_name": "system-monitor",
    "process_wasm_path": "/system-monitor.wasm",
    "on_exit": "Restart",
    "request_networking": true,
    "request_capabilities": [
      "homepage:homepage:sys",
      "http-server:distro:sys",
      "vfs:distro:sys"
    ],
    "grant_capabilities": [
      {
        "process": "terminal:terminal:sys",
        "capabilities": ["messaging"]
      }
    ],
    "public": true
  }
]
```

### WebSocket Configuration
While WebSocket support is included with `http-server:distro:sys`, you must declare WebSocket endpoints in your Rust code:
```rust
#[hyperprocess(
    endpoints = vec![
        Binding::Http { 
            path: "/api", 
            config: HttpBindingConfig::new(false, false, false, None) 
        },
        Binding::WebSocket {  // Add this for WebSocket support
            path: "/ws",
            config: HttpBindingConfig::new(false, false, false, None)
        }
    ],
)]
```

### Common manifest.json Issues
- **"Failed to install: process_name mismatch"**: Ensure manifest.json process_name matches metadata.json package
- **"Capability not granted"**: Add the missing capability to request_capabilities
- **"App doesn't appear on homepage"**: Add `homepage:homepage:sys` capability
- **Build generates wrong manifest**: Check metadata.json is valid JSON with package/publisher fields

### Grant Capabilities Pattern
Most apps have empty `grant_capabilities`, but some scenarios require granting permissions:

```json
"grant_capabilities": [
  {
    "process": "terminal:terminal:sys",
    "capabilities": ["messaging"]
  }
]
```

**When to grant capabilities:**
- System utilities that manage other processes
- Development tools needing broad access
- Apps acting as capability proxies
- Security tools monitoring other processes

**Security Note**: Be very selective about granting capabilities. Most apps should keep `grant_capabilities` empty.

### Capability Request Patterns

#### Basic App (UI + API)
```json
"request_capabilities": [
  "homepage:homepage:sys",
  "http-server:distro:sys"
]
```

#### Data Storage App
```json
"request_capabilities": [
  "homepage:homepage:sys", 
  "http-server:distro:sys",
  "vfs:distro:sys",
  "sqlite:distro:sys"
]
```

#### External API Consumer
```json
"request_capabilities": [
  "homepage:homepage:sys",
  "http-server:distro:sys",
  "http-client:distro:sys",
  "timer:distro:sys"  // For periodic fetching
]
```

#### DeFi/Web3 App
```json
"request_capabilities": [
  "homepage:homepage:sys",
  "http-server:distro:sys",
  "http-client:distro:sys", 
  "eth:distro:sys"
]
```

#### P2P Collaborative App
```json
"request_networking": true,       // CRITICAL for P2P messaging
"request_capabilities": [
  "homepage:homepage:sys",
  "http-server:distro:sys",       // Serve UI and API
  "vfs:distro:sys"                // Store messages/files
]
```

### Best Practices
- Request only what you need
- Document why each capability is needed
- Handle missing capabilities gracefully
- Test with minimal capability sets first

## Frontend Development

### Frontend Stack
- **React 18** - UI framework
- **TypeScript** - Type safety  
- **Zustand** - State management
- **Vite** - Build tool
- **CSS Modules** or plain CSS - Styling

### Critical Requirements
**IMPORTANT**: Your `index.html` MUST include the `/our.js` script before any other scripts:
```html
<!doctype html>
<html lang="en">
  <head>
    <!-- ⚠️ CRITICAL: Must be FIRST script -->
    <script src="/our.js"></script>
    
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>My Hyperware App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```
Without this, you'll get "Node not connected" errors.

### Global Types Setup
```typescript
// src/types/global.ts
declare global {
  interface Window {
    our?: {
      node: string;       // e.g., "alice.os"
      process: string;    // e.g., "myapp:myapp:publisher.os"
    };
  }
}

export const isHyperwareEnvironment = (): boolean => {
  return typeof window !== 'undefined' && window.our !== undefined;
};

export const getNodeId = (): string | null => {
  return window.our?.node || null;
};
```

### API Communication Patterns

**IMPORTANT**: Backend HTTP methods return String or Result<String, String>. Complex data is serialized as JSON strings that must be parsed on frontend.

```typescript
// src/utils/api.ts
export async function makeApiCall<TRequest, TResponse>(
  method: string,
  data?: TRequest
): Promise<TResponse> {
  const body = data !== undefined 
    ? { [method]: data }
    : { [method]: "" };  // Empty string for no params

  const response = await fetch('/api', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });

  if (!response.ok) {
    throw new Error(`API Error: ${response.status}`);
  }

  return response.json();
}

// Typed API methods
export const api = {
  // No parameters - backend returns JSON string
  async getStatus() {
    const response = await makeApiCall<string, string>('GetStatus', "");
    return JSON.parse(response) as StatusResponse;
  },

  // Single parameter
  async getItem(id: string) {
    const response = await makeApiCall<string, string>('GetItem', id);
    return JSON.parse(response) as Item;
  },

  // Multiple parameters (as JSON object)
  async createItem(name: string, description: string) {
    const response = await makeApiCall<string, string>(
      'CreateItem', 
      JSON.stringify({ name, description })
    );
    return JSON.parse(response) as CreateResponse;
  },
};
```

### State Management with Zustand

```typescript
// src/store/app.ts
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';

interface AppState {
  // Connection
  nodeId: string | null;
  isConnected: boolean;
  
  // Data
  items: Item[];
  currentItem: Item | null;
  
  // UI State
  isLoading: boolean;
  error: string | null;
}

interface AppActions {
  // Connection
  initialize: () => void;
  
  // Data operations
  fetchItems: () => Promise<void>;
  createItem: (data: CreateItemData) => Promise<void>;
  updateItem: (id: string, updates: Partial<Item>) => Promise<void>;
  deleteItem: (id: string) => Promise<void>;
  
  // UI operations
  setError: (error: string | null) => void;
  clearError: () => void;
}

export const useAppStore = create<AppState & AppActions>()(
  devtools(
    persist(
      immer((set, get) => ({
        // Initial state
        nodeId: null,
        isConnected: false,
        items: [],
        currentItem: null,
        isLoading: false,
        error: null,

        // Actions
        initialize: () => {
          const nodeId = getNodeId();
          set(state => {
            state.nodeId = nodeId;
            state.isConnected = nodeId !== null;
          });
          
          if (nodeId) {
            get().fetchItems();
          }
        },

        fetchItems: async () => {
          set(state => {
            state.isLoading = true;
            state.error = null;
          });

          try {
            const items = await api.getItems();
            set(state => {
              state.items = items;
              state.isLoading = false;
            });
          } catch (error) {
            set(state => {
              state.error = getErrorMessage(error);
              state.isLoading = false;
            });
          }
        },

        createItem: async (data) => {
          try {
            const response = await api.createItem(data);
            // Refresh to ensure consistency
            await get().fetchItems();
          } catch (error) {
            set(state => {
              state.error = getErrorMessage(error);
            });
            throw error;
          }
        },

        deleteItem: async (id: string) => {
          // Optimistic update
          set(state => {
            state.items = state.items.filter(item => item.id !== id);
          });
          
          try {
            await api.deleteItem(id);
          } catch (error) {
            // Revert on error
            await get().fetchItems();
            throw error;
          }
        },

        // ... other actions
      })),
      {
        name: 'app-storage',
        partialize: (state) => ({
          // Only persist UI preferences, not data
          filters: state.filters,
        }),
      }
    )
  )
);
```

### Real-time Updates

#### WebSocket Connection (Frontend)
```typescript
// src/hooks/useWebSocket.ts
import { useEffect, useRef } from 'react';

export function useWebSocket(
  url: string,
  onMessage: (data: any) => void,
  onConnect?: () => void,
  onDisconnect?: () => void
) {
  const wsRef = useRef<WebSocket | null>(null);
  const reconnectTimeoutRef = useRef<ReturnType<typeof setTimeout>>();
  
  useEffect(() => {
    const connect = () => {
      try {
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${wsProtocol}//${window.location.host}${url}`;
        
        const ws = new WebSocket(wsUrl);
        wsRef.current = ws;
        
        ws.onopen = () => {
          console.log('WebSocket connected');
          onConnect?.();
        };
        
        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            onMessage(data);
          } catch (error) {
            console.error('Failed to parse WebSocket message:', error);
          }
        };
        
        ws.onclose = () => {
          console.log('WebSocket disconnected');
          onDisconnect?.();
          
          // Auto-reconnect after 3 seconds
          reconnectTimeoutRef.current = setTimeout(connect, 3000);
        };
      } catch (error) {
        console.error('Failed to create WebSocket:', error);
      }
    };
    
    connect();
    
    return () => {
      if (reconnectTimeoutRef.current) {
        clearTimeout(reconnectTimeoutRef.current);
      }
      if (wsRef.current) {
        wsRef.current.close();
      }
    };
  }, [url]);
  
  const send = (data: any) => {
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify(data));
    }
  };
  
  return { send, ws: wsRef.current };
}
```

#### Polling Pattern (Simpler Alternative)
```typescript
// src/hooks/usePolling.ts
import { useEffect, useRef } from 'react';

export function usePolling(
  callback: () => void | Promise<void>,
  interval: number,
  enabled: boolean = true
) {
  const savedCallback = useRef(callback);
  
  useEffect(() => {
    savedCallback.current = callback;
  }, [callback]);
  
  useEffect(() => {
    if (!enabled) return;
    
    const tick = () => savedCallback.current();
    
    // Call immediately
    tick();
    
    const id = setInterval(tick, interval);
    return () => clearInterval(id);
  }, [interval, enabled]);
}

// Usage
const { fetchUpdates, isConnected } = useAppStore();

// Poll every 2 seconds when connected
usePolling(
  async () => {
    try {
      await fetchUpdates();
    } catch (error) {
      console.error('Polling error:', error);
    }
  },
  2000,
  isConnected
);
```

### Common UI Patterns

#### Modal System
```typescript
// src/components/Modal.tsx
import React, { useEffect } from 'react';
import { createPortal } from 'react-dom';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
  title?: string;
}

export const Modal: React.FC<ModalProps> = ({ isOpen, onClose, children, title }) => {
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
      
      const handleEscape = (e: KeyboardEvent) => {
        if (e.key === 'Escape') onClose();
      };
      document.addEventListener('keydown', handleEscape);
      
      return () => {
        document.body.style.overflow = '';
        document.removeEventListener('keydown', handleEscape);
      };
    }
  }, [isOpen, onClose]);
  
  if (!isOpen) return null;
  
  return createPortal(
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal" onClick={e => e.stopPropagation()}>
        {title && (
          <div className="modal-header">
            <h2>{title}</h2>
            <button className="close-button" onClick={onClose}>×</button>
          </div>
        )}
        <div className="modal-content">{children}</div>
      </div>
    </div>,
    document.body
  );
};
```

#### Form Validation
```typescript
interface FormErrors {
  name?: string;
  description?: string;
}

const validate = (): boolean => {
  const newErrors: FormErrors = {};
  
  if (!formData.name.trim()) {
    newErrors.name = 'Name is required';
  } else if (formData.name.length < 3) {
    newErrors.name = 'Name must be at least 3 characters';
  }
  
  if (!formData.description.trim()) {
    newErrors.description = 'Description is required';
  }
  
  setErrors(newErrors);
  return Object.keys(newErrors).length === 0;
};
```

#### Error Handling
```typescript
export class ApiError extends Error {
  constructor(
    message: string,
    public status?: number,
    public details?: unknown
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

export function getErrorMessage(error: unknown): string {
  if (error instanceof ApiError) return error.message;
  if (error instanceof Error) return error.message;
  if (typeof error === 'string') return error;
  return 'An unknown error occurred';
}
```

### Performance Optimizations

#### Memoization
```typescript
import React, { useMemo, memo } from 'react';

// Memoize expensive computations
const processedItems = useMemo(() => {
  return items
    .filter(item => item.active)
    .sort((a, b) => b.priority - a.priority);
}, [items]);

// Memoize components
const ListItem = memo<{ item: Item }>(({ item }) => {
  return <div>{item.name}</div>;
}, (prev, next) => prev.item.id === next.item.id);
```

#### Lazy Loading
```typescript
import React, { Suspense, lazy } from 'react';

const AdminPanel = lazy(() => import('./components/AdminPanel'));

export const App: React.FC = () => {
  return (
    <Suspense fallback={<LoadingSpinner />}>
      {userRole === 'admin' && <AdminPanel />}
    </Suspense>
  );
};
```

### P2P Chat UI Patterns

#### Auto-scrolling Messages
```typescript
const messageListRef = useRef<HTMLDivElement>(null);

useEffect(() => {
  if (messageListRef.current) {
    messageListRef.current.scrollTop = messageListRef.current.scrollHeight;
  }
}, [messages]);

<div className="message-list" ref={messageListRef}>
  {messages.map(message => (
    <div key={message.id} className={message.sender === myNodeId ? 'sent' : 'received'}>
      {message.content}
    </div>
  ))}
</div>
```

#### Reply Context
```typescript
const [replyingTo, setReplyingTo] = useState<Message | null>(null);

{replyingTo && (
  <div className="reply-context">
    <div>Replying to {replyingTo.sender}: {replyingTo.content}</div>
    <button onClick={() => setReplyingTo(null)}>×</button>
  </div>
)}
```

#### File Upload with Preview
```typescript
const isImageFile = (mimeType: string): boolean => {
  return mimeType.startsWith('image/');
};

// Display image preview
{message.file_info && isImageFile(message.file_info.mime_type) && (
  <img 
    src={loadedImages[message.file_info.file_id]} 
    alt={message.file_info.file_name}
    style={{ maxWidth: '300px', maxHeight: '300px' }}
  />
)}
```

### Dynamic UI Paths (Frontend)

```typescript
// Extract path parameters
export function getPathParam(paramName: string): string | null {
  const pathParts = window.location.pathname.split('/');
  const paramIndex = pathParts.indexOf(paramName);
  
  if (paramIndex !== -1 && paramIndex < pathParts.length - 1) {
    return pathParts[paramIndex + 1];
  }
  
  // For pattern like /call/<id>
  const match = window.location.pathname.match(/\/call\/([^\/]+)/);
  return match ? match[1] : null;
}

const callId = getPathParam('call');
```

### Audio/WebRTC Patterns

```typescript
// Basic audio capture
export class AudioService {
  private audioContext: AudioContext | null = null;
  private mediaStream: MediaStream | null = null;
  
  async initialize() {
    this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
    
    this.mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
      }
    });
    
    const source = this.audioContext.createMediaStreamSource(this.mediaStream);
    // Process audio...
  }
  
  stop() {
    this.mediaStream?.getTracks().forEach(track => track.stop());
    this.audioContext?.close();
  }
}

// Voice Activity Detection (VAD)
export class VadService {
  private threshold: number = 0.01;
  
  processAudioLevel(audioData: Float32Array): boolean {
    // Calculate RMS
    let sum = 0;
    for (let i = 0; i < audioData.length; i++) {
      sum += audioData[i] * audioData[i];
    }
    const rms = Math.sqrt(sum / audioData.length);
    
    return rms > this.threshold;
  }
}
```

## WebSocket and Real-time Patterns

### Enum-based Message Protocol

Use strongly-typed enums for WebSocket messages:

```rust
#[derive(Debug, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum WSMessage {
    // Client -> Server
    Join { room_id: String, auth_token: Option<String> },
    Leave,
    SendData { content: String },
    UpdateState { key: String, value: serde_json::Value },
    
    // Server -> Client
    JoinSuccess { 
        user_id: String,
        room_state: RoomState,
        participants: Vec<Participant>,
    },
    JoinError { reason: String },
    StateUpdate { updates: HashMap<String, serde_json::Value> },
    ParticipantJoined { participant: Participant },
    ParticipantLeft { user_id: String },
    DataReceived { from_id: String, content: String },
}
```

### WebSocket Handler Pattern
```rust
#[hyperprocess(
    endpoints = vec![
        Binding::WebSocket { 
            path: "/ws", 
            config: HttpBindingConfig::default() 
        }
    ]
)]

#[ws]
fn handle_ws(&mut self, channel_id: u32, msg_type: WsMessageType, payload: LazyLoadBlob) {
    match msg_type {
        WsMessageType::Open => {
            // Track connection but don't add to room yet
            self.ws_connections.insert(channel_id, ConnectionState::Connected);
        }
        WsMessageType::Close => {
            self.handle_disconnect(channel_id);
        }
        WsMessageType::Message => {
            if let Ok(text) = String::from_utf8(payload.bytes) {
                if let Ok(msg) = serde_json::from_str::<WSMessage>(&text) {
                    self.handle_ws_message(channel_id, msg);
                }
            }
        }
        WsMessageType::Error => {
            self.handle_ws_error(channel_id);
        }
    }
}

fn handle_ws_message(&mut self, channel_id: u32, msg: WSMessage) {
    match msg {
        WSMessage::Join { room_id, auth_token } => {
            self.handle_join(channel_id, room_id, auth_token);
        }
        WSMessage::SendData { content } => {
            if let Some(user_id) = self.get_user_for_channel(channel_id) {
                self.broadcast_data(user_id, content);
            }
        }
        // Handle other message types...
    }
}

// Send message to specific channel
fn send_to_channel(&self, channel_id: u32, msg: WSMessage) {
    if let Ok(json) = serde_json::to_string(&msg) {
        get_server().send_ws_push(
            channel_id,
            WsMessageType::Text,
            LazyLoadBlob::new(Some("message"), json.into_bytes())
        );
    }
}

// Broadcast to all participants in a room
fn broadcast_to_room(&self, room_id: &str, msg: WSMessage, exclude: Option<&str>) {
    if let Some(room) = self.rooms.get(room_id) {
        for participant in &room.participants {
            if exclude.map_or(true, |ex| ex != participant.id) {
                if let Some(channel) = self.get_channel_for_user(&participant.id) {
                    self.send_to_channel(channel, msg.clone());
                }
            }
        }
    }
}
```

### State Management for Real-time Apps

```rust
#[derive(Default)]
pub struct RealTimeState {
    // WebSocket connections
    ws_connections: HashMap<u32, String>,  // channel_id -> user_id
    user_channels: HashMap<String, u32>,   // user_id -> channel_id
    
    // Room/session state
    rooms: HashMap<String, Room>,
    user_rooms: HashMap<String, String>,   // user_id -> room_id
}

#[derive(Clone, Serialize, Deserialize)]
pub struct Room {
    pub id: String,
    pub host_id: String,
    pub participants: Vec<Participant>,
    pub settings: RoomSettings,
    pub created_at: String,
}

impl RealTimeState {
    fn handle_join(&mut self, channel_id: u32, room_id: String, auth_token: Option<String>) {
        // Validate room exists
        if !self.rooms.contains_key(&room_id) {
            self.send_to_channel(channel_id, WSMessage::JoinError { 
                reason: "Room not found".to_string() 
            });
            return;
        }
        
        // Create participant
        let user_id = format!("user-{}", channel_id);
        let participant = Participant {
            id: user_id.clone(),
            display_name: format!("User{}", channel_id),
            role: self.determine_role(auth_token),
            joined_at: chrono::Utc::now().to_rfc3339(),
        };
        
        // Update state mappings
        self.ws_connections.insert(channel_id, user_id.clone());
        self.user_channels.insert(user_id.clone(), channel_id);
        self.user_rooms.insert(user_id.clone(), room_id.clone());
        
        // Add to room and notify
        if let Some(room) = self.rooms.get_mut(&room_id) {
            room.participants.push(participant.clone());
            
            // Send success to joiner
            self.send_to_channel(channel_id, WSMessage::JoinSuccess {
                user_id: user_id.clone(),
                room_state: self.get_room_state(&room_id),
                participants: room.participants.clone(),
            });
            
            // Notify others
            self.broadcast_to_room(&room_id, WSMessage::ParticipantJoined {
                participant,
            }, Some(&user_id));
        }
    }
    
    fn handle_disconnect(&mut self, channel_id: u32) {
        if let Some(user_id) = self.ws_connections.remove(&channel_id) {
            self.user_channels.remove(&user_id);
            
            if let Some(room_id) = self.user_rooms.remove(&user_id) {
                // Remove from room
                if let Some(room) = self.rooms.get_mut(&room_id) {
                    room.participants.retain(|p| p.id != user_id);
                    
                    // Notify others
                    self.broadcast_to_room(&room_id, WSMessage::ParticipantLeft {
                        user_id: user_id.clone(),
                    }, None);
                }
            }
        }
    }
}
```

### Audio/Video Streaming Patterns

```rust
// Audio data message format
#[derive(Serialize, Deserialize)]
pub struct AudioData {
    pub data: String,        // Base64 encoded audio
    pub sequence: u32,       // For ordering and loss detection
    pub timestamp: u64,      // For jitter buffer
    pub sample_rate: u32,
}

// Mix-minus audio distribution (everyone hears everyone except themselves)
fn distribute_audio(&self, sender_id: &str, audio: AudioData) {
    if let Some(room_id) = self.user_rooms.get(sender_id) {
        if let Some(room) = self.rooms.get(room_id) {
            for participant in &room.participants {
                if participant.id != sender_id {  // Mix-minus
                    if let Some(channel) = self.get_channel_for_user(&participant.id) {
                        self.send_to_channel(channel, WSMessage::AudioStream {
                            from_id: sender_id.to_string(),
                            data: audio.clone(),
                        });
                    }
                }
            }
        }
    }
}
```

### Dynamic UI Serving

Serve UI at dynamic paths for rooms/sessions:

```rust
#[http]
async fn create_room(&mut self, request_body: String) -> Result<String, String> {
    let room = Room {
        id: generate_room_id(),
        host_id: get_caller_id(),
        participants: vec![],
        settings: Default::default(),
        created_at: chrono::Utc::now().to_rfc3339(),
    };
    
    let room_id = room.id.clone();
    self.rooms.insert(room_id.clone(), room);
    
    // Serve UI at dynamic path
    get_server().serve_ui(
        &our(),
        format!("/room/{}", room_id),  // Dynamic path
        vec![],
        None,
        true
    )?;
    
    Ok(json!({ "room_id": room_id }).to_string())
}
```

### Polling Alternative to WebSockets

For P2P apps or when WebSockets aren't needed, polling provides a simpler alternative:

```rust
// Backend: Return only changes since last update
#[http]
async fn get_updates(&self, request_body: String) -> Result<String, String> {
    #[derive(Deserialize)]
    struct UpdateRequest {
        last_update_timestamp: String,
    }
    
    let req: UpdateRequest = serde_json::from_str(&request_body)?;
    
    // Return only changes since last update
    let updates = self.get_changes_since(&req.last_update_timestamp);
    Ok(serde_json::to_string(&updates)?)
}
```

```typescript
// Frontend: Poll for updates
const POLLING_INTERVAL = 5000; // 5 seconds

useEffect(() => {
  const fetchUpdates = async () => {
    const updates = await api.getUpdates({ 
      last_update_timestamp: lastUpdate 
    });
    if (updates.length > 0) {
      processUpdates(updates);
      setLastUpdate(updates[updates.length - 1].timestamp);
    }
  };
  
  // Initial fetch
  fetchUpdates();
  
  // Set up polling
  const intervalId = setInterval(fetchUpdates, POLLING_INTERVAL);
  
  return () => clearInterval(intervalId);
}, [lastUpdate]);
```

### WebSockets vs Polling

**Use WebSockets when:**
- Sub-second latency is critical (voice/video)
- High frequency updates (collaborative editing)
- Server needs to push data immediately
- Bandwidth efficiency is important

**Use Polling when:**
- Updates can tolerate 5-10 second delays
- Implementation simplicity is valued
- P2P architecture without central coordination
- Resilience to connection issues is important

### Performance Considerations

```rust
// Rate limiting for WebSocket messages
#[derive(Default)]
struct RateLimiter {
    message_counts: HashMap<String, VecDeque<Instant>>,
    max_messages_per_minute: usize,
}

impl RateLimiter {
    fn check_rate_limit(&mut self, user_id: &str) -> bool {
        let now = Instant::now();
        let counts = self.message_counts.entry(user_id.to_string())
            .or_insert_with(VecDeque::new);
        
        // Remove old entries
        while let Some(&front) = counts.front() {
            if now.duration_since(front) > Duration::from_secs(60) {
                counts.pop_front();
            } else {
                break;
            }
        }
        
        if counts.len() < self.max_messages_per_minute {
            counts.push_back(now);
            true
        } else {
            false
        }
    }
}
```

## Common Issues and Solutions

### Build Errors
- **"Failed to open manifest.json"**: Run `kit b --hyperapp` to generate
- **"process_name mismatch"**: Ensure metadata.json package matches manifest
- **"doesn't have capability"**: Add missing capability to manifest.json
- **"Failed to deserialize HTTP request"**: Add `request_body: String` parameter to handler
- **"Node not connected"**: Add `<script src="/our.js"></script>` to HTML head
- **"hyperware_process_lib is ambiguous"**: Remove it from Cargo.toml dependencies

### Type Errors
- **"the trait Serialize is not implemented"**: Add `#[derive(Serialize, Deserialize)]`
- **"WIT does not support Option"**: Use concrete types in function signatures
- **HashMap in parameters**: Convert to Vec before passing to/from functions
- **"Types not found in WIT"**: Return complex types as JSON strings or ensure all nested types are used in handlers
- **Helper function in hyperprocess impl**: Move helper methods to separate impl block

### P2P Issues
- **"Failed to parse ProcessId"**: Use format `process:package:publisher`
- **Message not received**: Ensure target process has `public: true` or grants permission
- **No response**: Always set `expects_response()` even for fire-and-forget
- **SendError**: Check target node is running, use correct node name
- **Remote method not found**: Ensure method has `#[remote]` attribute and names match exactly

### State Issues
- **State not persisting**: Check SaveOptions configuration
- **Deserialization errors**: Ensure all state fields are Serialize/Deserialize

### WebSocket Issues
- **WebSocket handler errors**: Handler must NOT be async - use `fn` not `async fn`
- **Connection fails**: Check endpoint configuration in hyperprocess macro
- **Binary data**: Use LazyLoadBlob with proper mime type

## Testing and Debugging

### Development Environment Setup

#### Local Node Testing
```bash
# Single node (default)
kit s

# Multiple local nodes for P2P testing
# Terminal 1
kit s --fake-node alice.os

# Terminal 2  
kit s --fake-node bob.os --port 8081

# Terminal 3
kit s --fake-node charlie.os --port 8082

# Enable verbose logging
RUST_LOG=debug kit s

# Custom port if default is taken
kit s --port 8083
```

### Backend Debugging (Rust)

#### Strategic println! Debugging
```rust
// Add context to all prints
impl AppState {
    fn debug_log(&self, context: &str, message: &str) {
        println!("[{}] {}: {}", 
            chrono::Utc::now().format("%H:%M:%S%.3f"),
            context,
            message
        );
    }
}

// Use in handlers
#[http]
async fn complex_operation(&mut self, request_body: String) -> Result<String, String> {
    self.debug_log("complex_operation", &format!("Request: {}", request_body));
    
    let parsed: MyRequest = serde_json::from_str(&request_body)
        .map_err(|e| {
            self.debug_log("complex_operation", &format!("Parse error: {}", e));
            format!("Invalid request: {}", e)
        })?;
    
    self.debug_log("complex_operation", &format!("Parsed: {:?}", parsed));
    // Operation logic...
    Ok("Success".to_string())
}
```

#### State Inspection
```rust
// Add debug endpoint to inspect state
#[http]
async fn debug_state(&self, _request_body: String) -> String {
    // Only in development!
    if cfg!(debug_assertions) {
        serde_json::json!({
            "node": our().node,
            "item_count": self.items.len(),
            "connected_nodes": self.connected_nodes,
            "last_sync": self.last_sync_time,
            // Don't expose sensitive data
        }).to_string()
    } else {
        "Debug disabled in production".to_string()
    }
}
```

#### P2P Communication Debugging
```rust
// Wrap remote calls with debugging
async fn debug_remote_call(
    &self,
    target: Address,
    method: &str,
    data: String,
) -> Result<String, String> {
    println!("\n=== P2P DEBUG START ===");
    println!("Target: {:?}", target);
    println!("Method: {}", method);
    println!("Request: {}", data);
    
    let start = std::time::Instant::now();
    let wrapper = json!({ method: data });
    
    let result = Request::new()
        .target(target)
        .body(serde_json::to_vec(&wrapper).unwrap())
        .expects_response(30)
        .send_and_await_response(30);
    
    let duration = start.elapsed();
    
    match &result {
        Ok(response) => {
            if let Ok(body) = response.body() {
                println!("Response ({}ms): {}", duration.as_millis(), String::from_utf8_lossy(&body));
            }
        }
        Err(e) => println!("Error ({}ms): {:?}", duration.as_millis(), e),
    }
    
    println!("=== P2P DEBUG END ===\n");
    
    result.map(|r| String::from_utf8_lossy(&r.body().unwrap_or_default()).to_string())
        .map_err(|e| format!("{:?}", e))
}
```

### Frontend Debugging (React/TypeScript)

#### API Call Debugging
```typescript
// src/utils/debug.ts
const DEBUG = import.meta.env.DEV;

export function debugLog(category: string, ...args: any[]) {
  if (DEBUG) {
    console.log(`[${new Date().toISOString()}] [${category}]`, ...args);
  }
}

// Enhanced API wrapper with debugging
export async function debugApiCall<T>(
  method: string,
  data: any,
  description: string
): Promise<T> {
  const requestId = Math.random().toString(36).substr(2, 9);
  
  debugLog('API', `[${requestId}] Starting: ${description}`);
  debugLog('API', `[${requestId}] Method: ${method}`);
  debugLog('API', `[${requestId}] Data:`, data);
  
  const startTime = performance.now();
  
  try {
    const result = await makeApiCall<any, T>(method, data);
    const duration = performance.now() - startTime;
    
    debugLog('API', `[${requestId}] Success (${duration.toFixed(2)}ms):`, result);
    return result;
  } catch (error) {
    const duration = performance.now() - startTime;
    debugLog('API', `[${requestId}] Error (${duration.toFixed(2)}ms):`, error);
    throw error;
  }
}
```

#### State Debugging with Zustand DevTools
```typescript
// Debug component
export const StoreDebugger: React.FC = () => {
  const store = useAppStore();
  
  if (!import.meta.env.DEV) return null;
  
  return (
    <div style={{
      position: 'fixed',
      bottom: 0,
      right: 0,
      background: 'black',
      color: 'white',
      padding: '10px',
      maxWidth: '300px',
      maxHeight: '200px',
      overflow: 'auto',
      fontSize: '12px',
      fontFamily: 'monospace',
    }}>
      <h4>Store State</h4>
      <pre>{JSON.stringify(store, null, 2)}</pre>
    </div>
  );
};
```

#### WebSocket Traffic Monitoring
```typescript
// Monitor WebSocket traffic in development
if (import.meta.env.DEV) {
  const originalWS = WebSocket;
  // @ts-ignore
  window.WebSocket = class extends originalWS {
    constructor(url: string, protocols?: string | string[]) {
      console.log(`🔌 WS Connecting to: ${url}`);
      super(url, protocols);
      
      this.addEventListener('open', () => console.log(`✅ WS Connected`));
      this.addEventListener('message', (event) => {
        try {
          const data = JSON.parse(event.data);
          console.log(`📨 WS Received:`, data);
        } catch {
          console.log(`📨 WS Received (raw):`, event.data);
        }
      });
      this.addEventListener('close', (event) => {
        console.log(`🔌 WS Closed: code=${event.code}`);
      });
      
      const originalSend = this.send.bind(this);
      this.send = (data: any) => {
        console.log(`📤 WS Send:`, data);
        return originalSend(data);
      };
    }
  };
}
```

### Testing Patterns

#### Backend Unit Testing (Rust)
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    fn create_test_state() -> AppState {
        AppState {
            items: vec![
                Item { id: "1".to_string(), name: "Test 1".to_string() },
                Item { id: "2".to_string(), name: "Test 2".to_string() },
            ],
            ..Default::default()
        }
    }
    
    #[test]
    fn test_item_creation() {
        let mut state = create_test_state();
        let initial_count = state.items.len();
        
        state.items.push(Item {
            id: "3".to_string(),
            name: "Test 3".to_string(),
        });
        
        assert_eq!(state.items.len(), initial_count + 1);
        assert_eq!(state.items.last().unwrap().name, "Test 3");
    }
    
    #[tokio::test]
    async fn test_async_operation() {
        let mut state = create_test_state();
        let result = state.process_items().await;
        assert!(result.is_ok());
    }
}
```

#### Frontend Integration Testing
```typescript
// src/__tests__/integration.test.ts
import { renderHook, act, waitFor } from '@testing-library/react';
import { useAppStore } from '../store/app';
import * as api from '../utils/api';

// Mock API
jest.mock('../utils/api');

describe('App Integration', () => {
  beforeEach(() => {
    useAppStore.setState({
      items: [],
      isLoading: false,
      error: null,
    });
  });
  
  it('fetches and displays items', async () => {
    const mockItems = [
      { id: '1', name: 'Item 1' },
      { id: '2', name: 'Item 2' },
    ];
    
    (api.getItems as jest.Mock).mockResolvedValue(mockItems);
    
    const { result } = renderHook(() => useAppStore());
    
    await act(async () => {
      await result.current.fetchItems();
    });
    
    await waitFor(() => {
      expect(result.current.items).toEqual(mockItems);
      expect(result.current.isLoading).toBe(false);
    });
  });
});
```

### P2P Testing Scenarios

#### Test Script
```bash
#!/bin/bash
# test-p2p.sh

echo "Starting P2P test environment..."

# Start nodes
kit s --fake-node alice.os &
ALICE_PID=$!
sleep 2

kit s --fake-node bob.os --port 8081 &
BOB_PID=$!
sleep 2

echo "Nodes started: Alice (PID: $ALICE_PID), Bob (PID: $BOB_PID)"
echo "Access Alice at http://localhost:8080"
echo "Access Bob at http://localhost:8081"

# Wait for user to finish testing
read -p "Press Enter to stop nodes..."

# Cleanup
kill $ALICE_PID $BOB_PID
echo "Test environment stopped"
```

#### P2P Test Checklist
```typescript
export const P2P_TEST_SCENARIOS = [
  {
    name: "Basic Connectivity",
    steps: [
      "Start two nodes (alice.os and bob.os)",
      "From Alice, try to connect to Bob",
      "Verify connection status on both nodes",
      "Check console logs for any errors",
    ],
  },
  {
    name: "Data Synchronization",
    steps: [
      "Create data on Alice node",
      "Trigger sync from Bob node",
      "Verify data appears on Bob",
      "Modify data on Bob",
      "Sync back to Alice",
      "Verify both nodes have same data",
    ],
  },
  {
    name: "Network Resilience",
    steps: [
      "Establish connection between nodes",
      "Stop Bob node (Ctrl+C)",
      "Try operation from Alice",
      "Verify graceful error handling",
      "Restart Bob node",
      "Verify automatic reconnection",
    ],
  },
];
```

### Performance Profiling

#### Backend Performance
```rust
// Simple timing macro
macro_rules! time_operation {
    ($name:expr, $body:expr) => {{
        let start = std::time::Instant::now();
        let result = $body;
        let duration = start.elapsed();
        println!("[PERF] {} took {:?}", $name, duration);
        result
    }};
}

// Usage
#[http]
async fn heavy_operation(&mut self, request_body: String) -> Result<String, String> {
    let parsed = time_operation!("parsing", {
        serde_json::from_str::<ComplexRequest>(&request_body)?
    });
    
    let result = time_operation!("processing", {
        self.process_complex_request(parsed)?
    });
    
    time_operation!("serializing", {
        Ok(serde_json::to_string(&result).unwrap())
    })
}
```

#### Frontend Performance
```typescript
export class PerformanceMonitor {
  private marks: Map<string, number> = new Map();
  
  start(label: string) {
    this.marks.set(label, performance.now());
  }
  
  end(label: string, threshold = 100) {
    const start = this.marks.get(label);
    if (!start) return;
    
    const duration = performance.now() - start;
    this.marks.delete(label);
    
    if (duration > threshold) {
      console.warn(`⚠️ Slow operation: ${label} took ${duration.toFixed(2)}ms`);
    }
    
    return duration;
  }
}
```

### Common Debugging Scenarios

#### "Why isn't my endpoint being called?"
```rust
// Diagnostic endpoint
#[http]
async fn diagnose_endpoint(&self, _request_body: String) -> String {
    json!({
        "node": our().node,
        "process": our().process,
        "endpoints_configured": true,
        "manifest_capabilities": self.capabilities.clone(),
    }).to_string()
}
```

#### "Why is my P2P call failing?"
```rust
#[http]
async fn diagnose_p2p(&self, request_body: String) -> String {
    let target_node: String = serde_json::from_str(&request_body).unwrap_or_default();
    let mut diagnostics = vec![];
    
    // Check ProcessId parsing
    match "app:app:publisher.os".parse::<ProcessId>() {
        Ok(pid) => diagnostics.push(format!("✅ ProcessId valid: {:?}", pid)),
        Err(e) => diagnostics.push(format!("❌ ProcessId error: {}", e)),
    }
    
    // Check target reachability
    if !target_node.is_empty() {
        // Ping test...
    }
    
    serde_json::to_string(&diagnostics).unwrap()
}
```

### Test Endpoints
```bash
# Test HTTP endpoints
curl -X POST http://localhost:8080/my-app:publisher/api \
  -H "Content-Type: application/json" \
  -d '{"GetStatus": ""}'

# Test with data
curl -X POST http://localhost:8080/my-app:publisher/api \
  -H "Content-Type: application/json" \
  -d '{"CreateItem": {"name": "Test", "description": "Test item"}}'

# Test debug endpoint
curl -X POST http://localhost:8080/my-app:publisher/api \
  -H "Content-Type: application/json" \
  -d '{"DebugState": ""}'
```

### Production Debugging

#### Conditional Logging
```rust
// Only in debug builds
#[cfg(debug_assertions)]
fn debug_log(&self, msg: &str) {
    println!("[DEBUG] {}", msg);
}

#[cfg(not(debug_assertions))]
fn debug_log(&self, _msg: &str) {
    // No-op in release
}
```

#### Error Reporting
```typescript
// Structured error reporting
export function reportError(error: Error, context: Record<string, any>) {
  const report = {
    message: error.message,
    stack: error.stack,
    context,
    timestamp: new Date().toISOString(),
    node: window.our?.node || 'unknown',
    userAgent: navigator.userAgent,
  };
  
  if (import.meta.env.PROD) {
    // Send to logging service
    api.logError(report).catch(console.error);
  } else {
    console.error('Error Report:', report);
  }
}
```

### Debug Checklist
1. **Build Issues**:
   - All HTTP methods have correct parameters?
   - No `hyperware_process_lib` in Cargo.toml?
   - All types are WIT-compatible?
   - `#[hyperprocess]` before impl block?

2. **Runtime Issues**:
   - `/our.js` script in HTML head?
   - Node is actually running?
   - Correct ProcessId format?
   - Frontend using correct API format?

3. **P2P Issues**:
   - Target node running?
   - Using real node names?
   - `expects_response` timeout set?
   - Method names match exactly?
   - Same publisher across nodes?

4. **State Issues**:
   - State is serializable?
   - Refreshing after mutations?
   - SaveOptions configured?

5. **Clean Build**:
   ```bash
   rm -rf target/ pkg/ ui/node_modules
   rm Cargo.lock
   kit b --hyperapp
   ```

## Best Practices

### Code Organization
- Keep HTTP handlers thin - delegate to impl methods
- Separate remote handlers from HTTP handlers
- Use type aliases for complex types
- Document capability requirements

### Error Handling
- Return `Result<T, String>` from handlers
- Provide user-friendly error messages
- Log errors for debugging
- Handle missing capabilities gracefully

### Performance
- Use pagination for large data sets
- Implement caching where appropriate
- Batch P2P messages when possible
- Set appropriate timeouts

### Security
- Validate all inputs
- Use parameterized SQL queries
- Request minimal capabilities
- Set `public: false` for sensitive apps
- Sanitize data before storing

### State Management
- Keep state normalized
- Use appropriate SaveOptions
- Consider using SQLite for complex queries
- Clean up old data periodically
- Version your state for migrations

### Authentication
- Use node IDs for identity (our().node)
- Implement role-based permissions in state
- Check permissions before operations
- Consider using `public: false` for restricted apps

## Common Patterns

### CRUD Operations
```rust
#[http]
async fn create(&mut self, data: String) -> Result<String, String> {
    let item: Item = serde_json::from_str(&data)?;
    let id = Uuid::new_v4().to_string();
    self.items.insert(id.clone(), item);
    Ok(json!({ "id": id }).to_string())
}

#[http]
async fn read(&self, id: String) -> Result<String, String> {
    self.items.get(&id)
        .map(|item| serde_json::to_string(item).unwrap())
        .ok_or_else(|| "Not found".to_string())
}

#[http]
async fn update(&mut self, id: String, data: String) -> Result<String, String> {
    let item: Item = serde_json::from_str(&data)?;
    self.items.insert(id, item);
    Ok("Updated".to_string())
}

#[http]
async fn delete(&mut self, id: String) -> Result<String, String> {
    self.items.remove(&id)
        .map(|_| "Deleted".to_string())
        .ok_or_else(|| "Not found".to_string())
}
```

### Search and Filter
```rust
#[http]
async fn search(&self, query: String, tags: Vec<String>) -> Result<Vec<Item>, String> {
    let results: Vec<_> = self.items.iter()
        .filter(|item| {
            let text_match = query.is_empty() || 
                item.name.contains(&query) ||
                item.description.contains(&query);
            let tag_match = tags.is_empty() ||
                tags.iter().any(|t| item.tags.contains(t));
            text_match && tag_match
        })
        .cloned()
        .collect();
    Ok(results)
}
```

### P2P Broadcasting
```rust
// Send to multiple nodes
for node in &self.peer_nodes {
    let target = Address::new(node.clone(), process_id.clone());
    Request::new()
        .target(target)
        .body(message.clone())
        .expects_response(30)
        .send();  // Fire and forget
}
```

### File Handling
```rust
// Store uploaded file
#[http]
async fn upload(&mut self, name: String, data: Vec<u8>) -> Result<String, String> {
    let id = Uuid::new_v4().to_string();
    let path = format!("/files/{}", id);
    create_file(&path, None)?;
    write_file(&path, data)?;
    Ok(json!({ "id": id, "path": path }).to_string())
}

// Serve file
#[http]
async fn download(&self, id: String) -> Result<Vec<u8>, String> {
    let path = format!("/files/{}", id);
    read_file(&path).map_err(|e| format!("File not found: {}", e))
}
```

### Timer and Scheduled Tasks
Requires `timer:distro:sys` capability:
```rust
use hyperware_process_lib::timer::set_timer;

// One-time timer
#[init]
async fn initialize(&mut self) {
    set_timer(60000);  // 1 minute
}

// Recurring timer pattern
match message {
    Message::Timer(context) => {
        self.perform_scheduled_task().await?;
        if self.timer_enabled {
            set_timer(60000);  // Reschedule
        }
    }
}

// Timer with context
timer::set_timer(5000, Some(json!({ 
    "action": "timeout",
    "task_id": task_id 
})));
```

### Dynamic UI Serving
```rust
use hyperware_process_lib::get_server;

// Serve UI at dynamic path (e.g., /room/123)
get_server().serve_ui(
    &our(),
    format!("/room/{}", room_id),
    vec![],
    None,
    true
)?;

// Remove UI
get_server().unserve_ui(&path)?;
```

## P2P Best Practices

### Always Set Timeouts
```rust
// ✓ Good - even for fire-and-forget
Request::new()
    .expects_response(30)
    .send();

// ✗ Bad - can hang
Request::new()
    .send();
```

### Group Messaging Pattern
```rust
// Send to multiple nodes without blocking
for recipient in recipients {
    let target = Address::new(recipient, process_id.clone());
    Request::new()
        .target(target)
        .body(data.clone())
        .expects_response(30)
        .send();  // Don't await
}
```

### Handle Network Failures
- Expect nodes to be offline
- Design for eventual consistency
- Use idempotent operations
- Test with multiple nodes (`kit s --fake-node alice.os`)

## Architecture Decisions

### When to Use What

**In-memory state + auto-persist**:
- Simple data structures
- Fast access needed
- Data fits in memory
- No complex queries

**SQLite**:
- Complex queries needed
- Large datasets
- Relational data
- Need ACID transactions

**VFS**:
- File uploads/downloads
- Large binary data
- User-generated content
- Import/export features

**P2P vs HTTP**:
- P2P: Direct node communication, distributed apps
- HTTP: External APIs, webhooks, traditional clients

**WebSockets vs Polling**:
- WebSockets: Sub-second latency, high-frequency updates
- Polling: Simpler implementation, resilient to disconnects

## Deployment Considerations

### Manifest Requirements
- Process name must match metadata.json package name
- Include all needed capabilities upfront
- Set appropriate `on_exit` behavior (Restart/None)
- Configure `public` based on security needs

### Multi-node Deployment
- Ensure nodes can reach each other (networking)
- Consider data consistency strategies
- Plan for node failures
- Test with realistic network conditions

### Performance Tuning
- Adjust SaveOptions based on data criticality
- Set appropriate HTTP timeouts
- Optimize database queries with indexes
- Monitor memory usage

### Security Hardening
- Minimize requested capabilities
- Validate all inputs
- Use HTTPS for external APIs
- Implement rate limiting
- Regular security audits

## Complete Application Examples

### Example 1: P2P Todo List with Sync

A collaborative todo list where items sync between nodes.

```rust
use hyperprocess_macro::*;
use hyperware_process_lib::{our, Address, ProcessId, Request, homepage::add_to_homepage};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Serialize, Deserialize, PartialEq, Clone)]
pub struct TodoItem {
    pub id: String,
    pub text: String,
    pub completed: bool,
    pub created_by: String,
    pub created_at: String,
    pub updated_at: String,
}

#[derive(Default, Serialize, Deserialize)]
pub struct TodoState {
    todos: HashMap<String, TodoItem>,
    shared_with: Vec<String>, // Nodes we're sharing with
    sync_enabled: bool,
}

#[hyperprocess(
    name = "P2P Todo",
    endpoints = vec![
        Binding::Http { path: "/api", config: HttpBindingConfig::default() }
    ],
    save_config = SaveOptions::EveryMessage,
)]
impl TodoState {
    #[init]
    async fn initialize(&mut self) {
        add_to_homepage("P2P Todo", Some("📝"), Some("/"), None);
        self.sync_enabled = true;
    }
    
    #[http]
    async fn create_todo(&mut self, request_body: String) -> Result<String, String> {
        let text: String = serde_json::from_str(&request_body)?;
        
        let todo = TodoItem {
            id: uuid::Uuid::new_v4().to_string(),
            text,
            completed: false,
            created_by: our().node.clone(),
            created_at: chrono::Utc::now().to_rfc3339(),
            updated_at: chrono::Utc::now().to_rfc3339(),
        };
        
        let id = todo.id.clone();
        self.todos.insert(id.clone(), todo.clone());
        
        // Sync with peers
        if self.sync_enabled {
            self.broadcast_todo_update(todo).await;
        }
        
        Ok(json!({ "id": id }).to_string())
    }
    
    #[http]
    async fn get_todos(&self, _request_body: String) -> String {
        let todos: Vec<&TodoItem> = self.todos.values().collect();
        serde_json::to_string(&todos).unwrap()
    }
    
    #[http]
    async fn share_with_node(&mut self, request_body: String) -> Result<String, String> {
        let node: String = serde_json::from_str(&request_body)?;
        
        if !self.shared_with.contains(&node) {
            self.shared_with.push(node.clone());
        }
        
        // Send initial sync
        self.sync_todos_with_node(node).await?;
        Ok("Shared successfully".to_string())
    }
    
    #[remote]
    async fn receive_todo_update(&mut self, todo_json: String) -> Result<String, String> {
        let todo: TodoItem = serde_json::from_str(&todo_json)?;
        
        // Update or insert based on timestamp
        match self.todos.get(&todo.id) {
            Some(existing) if existing.updated_at < todo.updated_at => {
                self.todos.insert(todo.id.clone(), todo);
            }
            None => {
                self.todos.insert(todo.id.clone(), todo);
            }
            _ => {} // Our version is newer
        }
        
        Ok("ACK".to_string())
    }
}

// Additional helper methods would go in a separate impl block
```

### Example 2: Real-time Voice Chat with WebSocket

Voice chat with role-based access and WebSocket support.

```rust
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum Role {
    Admin,
    Speaker,
    Listener,
}

// WebSocket message types
#[derive(Debug, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum WSMessage {
    // Client -> Server
    JoinCall { call_id: String, auth_token: Option<String> },
    LeaveCall,
    AudioData { data: String, sequence: u32 },
    Heartbeat,
    
    // Server -> Client
    JoinSuccess { 
        participant_id: String, 
        role: Role,
        participants: Vec<ParticipantInfo>,
    },
    AudioStream { participant_id: String, data: String, sequence: u32 },
}

#[hyperprocess(
    endpoints = vec![
        Binding::Http { path: "/api", config: HttpBindingConfig::default() },
        Binding::WebSocket { path: "/ws", config: HttpBindingConfig::default() }
    ],
)]
impl VoiceChatState {
    #[ws]
    fn handle_ws(&mut self, channel_id: u32, message_type: WsMessageType, payload: LazyLoadBlob) {
        match message_type {
            WsMessageType::Open => {
                println!("WebSocket opened: {}", channel_id);
            }
            WsMessageType::Message => {
                if let Ok(text) = String::from_utf8(payload.bytes) {
                    if let Ok(msg) = serde_json::from_str::<WSMessage>(&text) {
                        self.handle_ws_message(channel_id, msg);
                    }
                }
            }
            WsMessageType::Close => {
                self.handle_ws_close(channel_id);
            }
            _ => {}
        }
    }
    
    fn handle_audio_data(&mut self, channel_id: u32, data: String, sequence: u32) {
        if let Some(participant_id) = self.ws_connections.get(&channel_id.to_string()) {
            // Mix-minus: don't send audio back to sender
            self.broadcast_audio_to_others(participant_id, data, sequence);
        }
    }
}
```

### Example 3: P2P Chat Application

Simplified P2P chat with direct messages and group support.

```rust
#[derive(PartialEq, Clone, Debug, Serialize, Deserialize)]
pub struct ChatMessage {
    id: String,
    conversation_id: String,
    sender: String,
    recipient: Option<String>,      // None for groups
    recipients: Option<Vec<String>>, // Some for groups
    content: String,
    timestamp: String,              // RFC3339 for sorting
    reply_to: Option<MessageReplyInfo>,
}

impl ChatState {
    #[http]
    async fn send_message(&mut self, request_body: String) -> Result<String, String> {
        let req: SendRequest = serde_json::from_str(&request_body)?;
        let sender = self.my_node_id.clone().ok_or("Not initialized")?;
        
        // Determine if group or direct
        let is_group = req.recipient.starts_with("group_");
        let conversation_id = if is_group {
            req.recipient.clone()
        } else {
            // Create consistent conversation ID
            let mut participants = vec![sender.clone(), req.recipient.clone()];
            participants.sort();
            participants.join("|")
        };
        
        let message = ChatMessage {
            id: uuid::Uuid::new_v4().to_string(),
            conversation_id,
            sender: sender.clone(),
            recipient: if is_group { None } else { Some(req.recipient.clone()) },
            recipients: if is_group { Some(self.get_group_members(&req.recipient)) } else { None },
            content: req.content,
            timestamp: chrono::Utc::now().to_rfc3339(),
            reply_to: req.reply_to,
        };
        
        // Store locally
        self.store_message(&message);
        
        // Send to recipient(s)
        self.distribute_message(&message).await?;
        
        Ok(json!({ "message_id": message.id }).to_string())
    }
    
    #[remote]
    async fn receive_message(&mut self, message: ChatMessage) -> Result<String, String> {
        // Avoid duplicates
        if !self.has_message(&message.id) {
            self.store_message(&message);
        }
        Ok("ACK".to_string())
    }
}
```

### Example 4: Distributed Key-Value Store

A simple distributed database with eventual consistency.

```rust
#[derive(Serialize, Deserialize, Clone)]
pub struct KVEntry {
    pub key: String,
    pub value: String,
    pub version: u64,
    pub updated_by: String,
    pub updated_at: String,
}

impl KVStore {
    #[http]
    async fn set(&mut self, request_body: String) -> Result<String, String> {
        let req: SetRequest = serde_json::from_str(&request_body)?;
        
        let entry = KVEntry {
            key: req.key.clone(),
            value: req.value,
            version: self.data.get(&req.key).map(|e| e.version + 1).unwrap_or(1),
            updated_by: our().node.clone(),
            updated_at: chrono::Utc::now().to_rfc3339(),
        };
        
        self.data.insert(req.key.clone(), entry.clone());
        
        // Replicate to other nodes
        if self.replication_enabled {
            self.replicate_entry(entry).await;
        }
        
        Ok("OK".to_string())
    }
    
    #[remote]
    async fn replicate(&mut self, entry_json: String) -> Result<String, String> {
        let entry: KVEntry = serde_json::from_str(&entry_json)?;
        
        // Apply if newer version
        match self.data.get(&entry.key) {
            Some(existing) if existing.version < entry.version => {
                self.data.insert(entry.key.clone(), entry);
            }
            None => {
                self.data.insert(entry.key.clone(), entry);
            }
            _ => {} // Our version is newer
        }
        
        Ok("ACK".to_string())
    }
}
```

### Example 5: File Sharing with VFS

P2P file sharing using virtual filesystem.

```rust
#[http]
async fn upload_file(&mut self, name: String, mime_type: String, data: Vec<u8>) -> Result<String, String> {
    let file_id = uuid::Uuid::new_v4().to_string();
    let file_path = format!("/files/{}", file_id);
    
    // Store in VFS
    let vfs_address = Address::new(our().node.clone(), "vfs:distro:sys".parse::<ProcessId>()?);
    
    Request::new()
        .target(vfs_address)
        .body(json!({ "path": file_path, "action": "Write" }))
        .blob(LazyLoadBlob::new(Some("file"), data.clone()))
        .expects_response(5)
        .send_and_await_response(5)?;
    
    // Track file metadata
    let file = SharedFile {
        id: file_id.clone(),
        name,
        size: data.len() as u64,
        mime_type,
        owner: our().node.clone(),
        shared_with: vec![],
        uploaded_at: chrono::Utc::now().to_rfc3339(),
    };
    
    self.files.insert(file_id.clone(), file);
    Ok(file_id)
}

#[remote]
async fn request_file(&self, file_id: String) -> Result<Vec<u8>, String> {
    // Check permissions
    let requester = source().node.clone();
    if !self.can_access_file(&requester, &file_id) {
        return Err("Access denied".to_string());
    }
    
    // Read from VFS
    let file_path = format!("/files/{}", file_id);
    let vfs_address = Address::new(our().node.clone(), "vfs:distro:sys".parse::<ProcessId>()?);
    
    let response = Request::new()
        .target(vfs_address)
        .body(json!({ "path": file_path, "action": "Read" }))
        .expects_response(5)
        .send_and_await_response(5)?;
    
    response.blob()
        .map(|b| b.bytes)
        .ok_or_else(|| "File not found".to_string())
}
```

### Frontend Integration Pattern

```typescript
// Zustand store for state management
import { create } from 'zustand';

const useAppStore = create((set, get) => ({
  items: [],
  loading: false,
  error: null,
  
  fetchItems: async () => {
    set({ loading: true });
    try {
      const res = await fetch('/api', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ GetItems: "" })
      });
      const items = await res.json();
      set({ items, loading: false });
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  },
  
  createItem: async (data) => {
    const res = await fetch('/api', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ CreateItem: data })
    });
    if (res.ok) {
      await get().fetchItems(); // Refresh
    }
  }
}));

// React component
export function App() {
  const { items, loading, fetchItems, createItem } = useAppStore();
  
  useEffect(() => {
    fetchItems();
    // Poll for updates
    const interval = setInterval(fetchItems, 5000);
    return () => clearInterval(interval);
  }, []);
  
  return (
    <div>
      {/* UI implementation */}
    </div>
  );
}
```

## Summary

Hyperware provides a unique platform for building P2P applications with:
- Strong isolation via WebAssembly
- Capability-based security
- Built-in persistence
- Native P2P messaging
- Integrated HTTP/WebSocket support

Key principles:
- Work within WIT type constraints
- Request only needed capabilities
- Handle errors gracefully
- Design for distribution
- Keep security in mind

The hyperprocess framework abstracts much complexity while providing flexibility for various application types from simple CRUD apps to complex P2P systems.